<!DOCTYPE html>
<html lang="en" style="height: 100%; width: 100%; margin: 0;">
<head>
    <meta charset="UTF-8">
    <title>Temp</title>
    <script src="lib/js/external/gl-matrix-min.js"></script>
    <script src="lib/js/external/glmath.min.js"></script>
    <script src="lib/js/external/jquery-3.2.1.min.js"></script>
    <script src="lib/js/external/webgl-debug.js"></script>
    <script src="lib/js/renderer/program_manager.js"></script>
    <script src="lib/js/renderer/attribute_manager.js"></script>
    <script src="lib/js/material/phong.js"></script>
    <script src="lib/js/game/game_manager.js"></script>
    <script src="lib/js/scene_graph/object_3d.js"></script>
    <script src="lib/js/scene_graph/light.js"></script>
    <script src="lib/js/scene_graph/ambient_light.js"></script>
    <script src="lib/js/scene_graph/point_light.js"></script>
    <script src="lib/js/scene_graph/directional_light.js"></script>
    <script src="lib/js/scene_graph/scene.js"></script>
    <script src="lib/js/scene_graph/mesh_object.js"></script>
    <script src="lib/js/scene_graph/camera.js"></script>

    <script src="lib/js/renderer/renderer.js"></script>

    <script id="phong_fragment" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        #define MAX_DIR_LIGHTS 10
        #define MAX_POINT_LIGHTS 10

        struct DirectionalLight {
            vec3 direction;
            vec3 color;
            float intensity;
        };

        struct PointLight {
            vec3 position;
            vec3 color;
            float max_distance;
            float decay;
            float intensity;
        };

        uniform vec3 ambient;

        uniform DirectionalLight dir_lights[MAX_DIR_LIGHTS];
        uniform PointLight point_lights[MAX_POINT_LIGHTS];

        struct Material {
            vec3 diffuse_color;
            vec3 specular_color;
            float shininess;
        };

        uniform Material material;

        // From vertex shader
        in vec3 frag_normal;
        in vec3 frag_position;

        out vec4 color;

        // Calculates the point light color contribution
        vec3 calcPointLight (PointLight light, vec3 normal, vec3 view_dir) {

            vec3 light_dir = normalize(light.position - frag_position);

            // Difuse
            float diffuse_f = max(dot(normal, light_dir), 0.0f);

            // Specular
            vec3 reflect_dir = reflect(-light_dir, normal);
            float specular_f = pow(max(dot(view_dir, reflect_dir), 0.0f), material.shininess);

            // Attenuation
            float distance = length(light.position - frag_position);
            float attenuation = 1.0f / (1.0f + 0.001f * distance + 0.0001f * (distance * distance));

            // Combine results
            vec3 diffuse  = light.color * diffuse_f * material.diffuse_color * attenuation;
            vec3 specular = light.color * diffuse_f * material.specular_color * attenuation;

            return (diffuse + specular);
        }

        vec3 calcDirectLight (DirectionalLight light, vec3 normal, vec3 view_dir) {

            vec3 light_dir = normalize(light.direction);

            // Difuse
            float diffuse_f = max(dot(normal, light_dir), 0.0f);

            // Specular
            vec3 reflect_dir = reflect(-light_dir, normal);
            float specular_f = pow(max(dot(view_dir, reflect_dir), 0.0f), material.shininess);

            // Combine results
            vec3 diffuse  = light.color  * diffuse_f * material.diffuse_color;
            vec3 specular = light.color * specular_f * material.specular_color;

            return (diffuse + specular);
        }


        void main() {
            vec3 normal = normalize(frag_normal);
            vec3 view_dir = normalize(-frag_position);

            // Calculate combined light contribution
            //vec3 combined = ambient;
            vec3 combined = vec3(0.0, 0.0, 0.0);

            for (int i = 0; i < MAX_DIR_LIGHTS; i++) {
                combined += calcDirectLight(dir_lights[i], normal, view_dir);
            }
            for (int i = 0; i < MAX_POINT_LIGHTS; i++) {
                combined += calcPointLight(point_lights[i], normal, view_dir);
            }

            color = vec4(combined, 1.0);
        }

    </script>

    <script id="phong_vertex" type="x-shader/x-vertex">#version 300 es
        precision mediump float;

        uniform mat4 mvmat; // Model View Matrix
        uniform mat4 pmat;  // Projection Matrix
        uniform mat3 nmat;  // Normal Matrix

        in vec3 position;       // Vertex position
        in vec3 normal;      // Vertex normal

        // Output transformed vertex position and normal
        out vec3 frag_position;
        out vec3 frag_normal;

        void main() {
            // Model view position
            vec4 position_h = mvmat * vec4(position, 1.0);

            // Projected position
            gl_Position = pmat * position_h;

            frag_position = vec3(position_h) / position_h.w;
            // Transform normals
            frag_normal = vec3(nmat * normal);
        }
    </script>

    <script>

        $(document).ready(function() {
            var a = new GameManager($("#game_canvas")[0]);
        });
    </script>
</head>
<body style="height: 100%; width: 100%; margin: 0;">
<canvas id="game_canvas" style="width: 100%; height: 100%; position: absolute"></canvas>

</body>
</html>